
syntax = "proto3";

package XS2APIProtocol;

import "xs2clientprotocol/common.proto";

//
// Observation - Feature Layer
//

message ObservationFeatureLayer {
  FeatureLayers renders = 1;
  FeatureLayersMinimap minimap_renders = 2;
}

message FeatureLayers {
  ImageData height_map = 1;                // uint8. Terrain height. World space units of [-200, 200] encoded into [0, 255].
  ImageData visibility_map = 2;            // uint8. 0=Hidden, 1=Fogged, 2=Visible, 3=FullHidden
  ImageData creep = 3;                     // 1-bit. Zerg creep.
  ImageData power = 4;                     // 1-bit. Protoss power.
  ImageData player_id = 5;                 // uint8. Participants: [1, 15] Neutral: 16
  ImageData unit_type = 6;                 // int32. Unique identifier for type of unit.
  ImageData selected = 7;                  // 1-bit. Selected units.
  ImageData unit_hit_points = 8;           // int32.
  ImageData unit_hit_points_ratio = 17;    // uint8. Ratio of current health to max health. [0%, 100%] encoded into [0, 255].
  ImageData unit_energy = 9;               // int32.
  ImageData unit_energy_ratio = 18;        // uint8. Ratio of current energy to max energy. [0%, 100%] encoded into [0, 255].
  ImageData unit_shields = 10;             // int32.
  ImageData unit_shields_ratio = 19;       // uint8. Ratio of current shields to max shields. [0%, 100%] encoded into [0, 255].
  ImageData player_relative = 11;          // uint8. See "Alliance" enum in raw.proto. Range: [1, 4] 
  ImageData unit_density_aa = 14;          // uint8. Density of units overlapping a pixel, anti-aliased. [0.0, 16.0f] encoded into [0, 255].
  ImageData unit_density = 15;             // uint8. Count of units overlapping a pixel.
  ImageData effects = 20;                  // uint8. Visuals of persistent abilities. (eg. Psistorm)
  ImageData hallucinations = 21;           // 1-bit. Whether the unit here is a hallucination.
  ImageData cloaked = 22;                  // 1-bit. Whether the unit here is cloaked. Hidden units will show up too, but with less details in other layers.
  ImageData blip = 23;                     // 1-bit. Whether the unit here is a blip.
  ImageData buffs = 24;                    // int32. One of the buffs applied to this unit. Extras are ignored.
  ImageData buff_duration = 26;            // uint8. Ratio of buff remaining. [0%, 100%] encoded into [0, 255].
  ImageData active = 25;                   // 1-bit. Whether the unit here is active.
  ImageData build_progress = 27;           // uint8. How far along the building is building something. [0%, 100%] encoded into [0, 255].
  ImageData buildable = 28;                // 1-bit. Whether a building can be built here.
  ImageData pathable = 29;                 // 1-bit. Whether a unit can walk here.
  ImageData placeholder = 30;              // 1-bit. Whether the unit here is a placeholder building to be constructed.
}

message FeatureLayersMinimap {
  ImageData height_map = 1;                // uint8. Terrain height. World space units of [-200, 200] encoded into [0, 255].
  ImageData visibility_map = 2;            // uint8. 0=Hidden, 1=Fogged, 2=Visible, 3=FullHidden
  ImageData creep = 3;                     // 1-bit. Zerg creep.
  ImageData camera = 4;                    // 1-bit. Area covered by the camera.
  ImageData player_id = 5;                 // uint8. Participants: [1, 15] Neutral: 16
  ImageData player_relative = 6;           // uint8. See "Alliance" enum in raw.proto. Range: [1, 4] 
  ImageData selected = 7;                  // 1-bit. Selected units.
  ImageData alerts = 9;                    // 1-bit. Shows 'UnitAttacked' alert location.
  ImageData buildable = 10;                // 1-bit. Whether a building can be built here.
  ImageData pathable = 11;                 // 1-bit. Whether a unit can walk here.

  // Cheat layers, enable with SpatialCameraSetup.allow_cheating_layers.
  ImageData unit_type = 8;                 // int32. Unique identifier for type of unit.
}


//
// Observation - Rendered
//

message ObservationRender {
  ImageData map = 1;
  ImageData minimap = 2;
}


//
// Action
//

message ActionSpatial {
  oneof action {
    ActionSpatialUnitCommand unit_command = 1;
    ActionSpatialCameraMove camera_move = 2;
    ActionSpatialUnitSelectionPoint unit_selection_point = 3;
    ActionSpatialUnitSelectionRect unit_selection_rect = 4;
  }
}

message ActionSpatialUnitCommand {
  int32 ability_id = 1;
  oneof target {
    PointI target_screen_coord = 2;
    PointI target_minimap_coord = 3;
  }

  bool queue_command = 4;          // Equivalent to shift+command.
}

message ActionSpatialCameraMove {
  PointI center_minimap = 1;       // Simulates a click on the minimap to move the camera.
}

message ActionSpatialUnitSelectionPoint {
  PointI selection_screen_coord = 1;
  enum Type {
	Type_Error= 0;
    Select = 1;         // Equivalent to normal click. Changes selection to unit.
    Toggle = 2;         // Equivalent to shift+click. Toggle selection of unit.
    AllType = 3;        // Equivalent to control+click. Selects all units of a given type.
    AddAllType = 4;     // Equivalent to shift+control+click. Selects all units of a given type.
  }
  Type type = 2;
}

message ActionSpatialUnitSelectionRect {
  repeated RectangleI selection_screen_coord = 1;   // Eventually this should not be an array, but a single field (multiple would be cheating).
  bool selection_add = 2;                  // Equivalent to shift+drag. Adds units to selection.
}
